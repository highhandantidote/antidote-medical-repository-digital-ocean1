I’ve logged in using the test doctor credentials (testdoctor@antidote.com, password: Doctor1234) as instructed, but I’m encountering an issue: the dashboard menu is showing the user dashboard instead of the doctor dashboard, even though I’m logged in as a doctor. Please refer to the screenshot I provided, which shows the dashboard menu with options like "Saved Items," "My Appointments," "My Reviews," "My Community Posts," "Notifications," and "Preferences"—these are user-specific options, not doctor-specific ones like "Patient Leads," "My Procedures," etc. This suggests the application is not correctly identifying the user’s role and rendering the appropriate dashboard.

Let’s investigate and resolve this issue step by step. Please ensure that no existing data is lost and none of the current working functionalities (such as leads, procedures, or any other implemented features) are disturbed. To avoid any data loss, please back up the current database before making any changes.

1. Back Up the Database
Before making any changes, back up the current database to ensure no data is lost. Run the following command:
cp instance/antidote.db instance/antidote_backup_$(date +%F_%H-%M-%S).db
After running the command, verify the backup file exists by running:
ls -l instance/
2. Verify the Test Doctor Account Role
Open the add_test_doctor.py or restore_test_data.py file (whichever was last used to create the test doctor account) and check that the test doctor account (testdoctor@antidote.com) is created with the correct role set to role='doctor'. The relevant code should look like this:
text

Copy
from app import app, db
from models import User, Doctor

with app.app_context():
    user = User(
        email='testdoctor@antidote.com',
        name='Test Doctor',
        role='doctor',  # Confirm this is set to 'doctor'
        phone_number='1234567890',
        is_verified=True
    )
    user.set_password('Doctor1234')
    db.session.add(user)
    db.session.commit()

    doctor = Doctor(
        user_id=user.id,
        name='Dr. Test',
        specialty='Plastic Surgery',
        experience=10,
        city='New York',
        state='NY',
        hospital='Test Hospital',
        consultation_fee=200,
        is_verified=True,
        rating=4.5,
        review_count=10,
        bio='Experienced plastic surgeon.'
    )
    db.session.add(doctor)
    db.session.commit()

    print("Test doctor created: testdoctor@antidote.com / Doctor1234")
If the role is incorrect or missing, update the script to include role='doctor' as shown above.
Save the file and run the script to update the user by executing:
python add_test_doctor.py (or python restore_test_data.py if that’s the script being used)
3. Check and Update the Login Logic
Open the routes.py file and locate the login route, which is likely defined as @web.route('/login', methods=['GET', 'POST']). This route handles user authentication. Currently, it might be redirecting all users to the user dashboard regardless of their role. Update the login route to redirect based on the user’s role. Replace the existing login route with the following code:
text

Copy
from flask import render_template, redirect, url_for, flash
from flask_login import login_user, current_user
from .forms import LoginForm
from .models import User, Doctor

@web.route('/login', methods=['GET', 'POST'])
def login():
    if current_user.is_authenticated:
        if current_user.role == 'doctor':
            doctor = Doctor.query.filter_by(user_id=current_user.id).first()
            if doctor:
                return redirect(url_for('web.doctor_dashboard', doctor_id=doctor.id))
        return redirect(url_for('web.user_dashboard'))  # Default to user dashboard for non-doctors
    
    form = LoginForm()
    if form.validate_on_submit():
        user = User.query.filter_by(email=form.email.data).first()
        if user and user.check_password(form.password.data):
            login_user(user)
            flash('Login successful!', 'success')
            if user.role == 'doctor':
                doctor = Doctor.query.filter_by(user_id=user.id).first()
                if doctor:
                    return redirect(url_for('web.doctor_dashboard', doctor_id=doctor.id))
            return redirect(url_for('web.user_dashboard'))  # Default to user dashboard for non-doctors
        else:
            flash('Invalid email or password.', 'danger')
    return render_template('login.html', form=form)
Save the file. This update ensures that after a successful login, a user with the doctor role is redirected to /dashboard/doctor/<doctor_id>, while other users are redirected to the user dashboard.
4. Update the Doctor Dashboard Route Logic
Still in routes.py, locate the doctor_dashboard route, which is likely defined as @web.route('/dashboard/doctor/<int:doctor_id>'). The current implementation might not be rendering the correct template or might be redirecting due to role or authorization checks. Ensure it renders the dashboard_doctor.html template and passes the necessary data. Replace the existing doctor_dashboard route with the following code:
text

Copy
from flask import render_template, redirect, url_for, flash
from flask_login import login_required, current_user
from .models import Doctor, Lead

@web.route('/dashboard/doctor/<int:doctor_id>')
@login_required
def doctor_dashboard(doctor_id):
    if current_user.role != 'doctor':
        flash('Unauthorized access. Only doctors can access this dashboard.', 'danger')
        return redirect(url_for('web.index'))
    doctor = Doctor.query.get_or_404(doctor_id)
    if doctor.user_id != current_user.id:
        flash('Unauthorized access. You can only view your own dashboard.', 'danger')
        return redirect(url_for('web.index'))
    leads = Lead.query.filter_by(doctor_id=doctor.id).all()
    return render_template('dashboard_doctor.html', doctor=doctor, leads=leads)
Save the file. This ensures that only users with the doctor role can access the doctor dashboard, and it redirects to the homepage if the user is not authorized or if the doctor ID doesn’t match the logged-in user.
5. Verify the Template Rendering
Open the templates/dashboard_doctor.html file and ensure it contains the doctor-specific dashboard menu and content. It should look something like this:
text

Copy
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Doctor Dashboard - {{ doctor.name }}</title>
    <!-- Include CSS and other head content -->
</head>
<body>
    <div class="container">
        <div class="row">
            <div class="col-md-3">
                <h4>Doctor Profile</h4>
                <p>{{ doctor.name }}</p>
                <p>★ {{ doctor.rating }} ({{ doctor.review_count }} reviews)</p>
                <a href="#" class="btn btn-outline-primary">Edit Profile</a>

                <h4 class="mt-4">Dashboard Menu</h4>
                <ul class="list-group">
                    <li class="list-group-item"><a href="{{ url_for('web.doctor_dashboard', doctor_id=doctor.id) }}">Overview</a></li>
                    <li class="list-group-item"><a href="{{ url_for('web.doctor_appointments', doctor_id=doctor.id) }}">Appointments</a></li>
                    <li class="list-group-item"><a href="{{ url_for('web.doctor_leads', doctor_id=doctor.id) }}">Patient Leads</a></li>
                    <li class="list-group-item"><a href="{{ url_for('web.doctor_reviews', doctor_id=doctor.id) }}">Reviews</a></li>
                    <li class="list-group-item"><a href="{{ url_for('web.doctor_procedures', doctor_id=doctor.id) }}">My Procedures</a></li>
                    <li class="list-group-item"><a href="{{ url_for('web.doctor_availability', doctor_id=doctor.id) }}">Availability</a></li>
                    <li class="list-group-item"><a href="{{ url_for('web.doctor_gallery', doctor_id=doctor.id) }}">Gallery</a></li>
                    <li class="list-group-item"><a href="{{ url_for('web.doctor_community', doctor_id=doctor.id) }}">Community</a></li>
                    <li class="list-group-item"><a href="{{ url_for('web.doctor_verification', doctor_id=doctor.id) }}">Verification <span class="badge bg-warning">NEW</span></a></li>
                </ul>
            </div>
            <div class="col-md-9">
                <h3>Overview</h3>
                <div class="row">
                    <div class="col-md-4">
                        <h5>Leads</h5>
                        <p>{{ leads|length }} New patient inquiries</p>
                    </div>
                    <div class="col-md-4">
                        <h5>Appointments</h5>
                        <p>0 Upcoming consultations</p>
                    </div>
                    <div class="col-md-4">
                        <h5>Reviews</h5>
                        <p>{{ doctor.review_count }} Patient feedback</p>
                    </div>
                </div>
                <h3>Recent Activity</h3>
                <p>No recent activity to display</p>
            </div>
        </div>
    </div>
</body>
</html>
If this file is missing or contains user dashboard content, replace it with the above code to ensure it reflects the doctor dashboard.
Save the file.
6. Test the Changes
Restart the application by running:
Restarted Start application
Log out (if logged in) and navigate to the login page (/login).
Log in with the test doctor credentials (testdoctor@antidote.com, password: Doctor1234).
After logging in, manually navigate to /dashboard/doctor/1 and check if the doctor dashboard is displayed with the correct menu options (e.g., "Patient Leads," "My Procedures," etc.).
If it still redirects to the homepage, check the Flask logs or browser console for any errors and let me know what you find.
7. Additional Debugging (If Needed)
If the issue persists, open routes.py again and search for any other routes or middleware that might interfere with the doctor dashboard route (e.g., a global redirect or role check). Look for lines containing redirect or role near the doctor_dashboard definition and share them with me.
Also, verify that the Doctor model in models.py correctly links to the User model via the user_id foreign key, and that the test doctor has a corresponding Doctor entry.